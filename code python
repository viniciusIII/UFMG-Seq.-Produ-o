import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from collections import deque

# ==============================================================================
# PARTE 1: ESTRUTURAS BÁSICAS
# Aqui a gente define o que é um Job e o que é um Nó da árvore.
# ==============================================================================

class Job:
    # O construtor recebe os dados do problema.
    # id = identificador, p = tempo de processamento, d = due date (prazo), w = peso.
    def __init__(self, id, processing_time, due_date, weight):
        self.id = id
        self.p = processing_time
        self.d = due_date
        self.w = weight
    
    def __repr__(self):
        return f"Job{self.id}"

class Node:
    # Essa classe representa cada "bolinha" da nossa árvore de Branch and Bound.
    # A lógica que a gente escolheu (baseada no Pinedo) é sequenciar de TRÁS PRA FRENTE.
    # Por isso temos 'sequence' (o que já definimos no final) e 'remaining_jobs' (o que falta agendar).
    def __init__(self, level, sequence, remaining_jobs, parent=None):
        self.level = level
        self.sequence = sequence  # Jobs já fixados nas últimas posições (do fim pro começo)
        self.remaining_jobs = remaining_jobs  # Quem ainda tá na briga pra entrar na sequência
        self.lower_bound = float('inf') # Começa infinito, a gente vai calcular jaja usando a relaxação
        self.parent = parent # Quem gerou esse nó (pra desenhar a linha depois)
        self.children = []
        self.pruned = False # Se for True, a gente cortou esse galho (PODA!)
        self.is_complete = len(remaining_jobs) == 0 # Se não sobrou job, achamos uma folha completa
        self.id = None
        self.position = None
    
    # Isso aqui é só pra printar bonito no gráfico depois.
    # Mostra asteriscos (*) onde ainda não decidimos e os IDs onde já decidimos.
    def __repr__(self):
        if not self.sequence:
            return "(,,,,,)"
        
        # Criar representação com asteriscos e jobs sequenciados
        total_jobs = len(self.sequence) + len(self.remaining_jobs)
        representation = ['*'] * total_jobs
        
        # Preencher da direita para esquerda com jobs sequenciados
        # Lembra: no método do Pinedo a gente fixa as últimas posições primeiro!
        for i, job in enumerate(self.sequence):
            representation[total_jobs - i - 1] = str(job.id)
        
        return f"({','.join(representation)})"

# ==============================================================================
# PARTE 2: O ALGORITMO BRANCH AND BOUND
# Aqui tá a inteligência do negócio. Vamos implementar o cálculo do atraso,
# a relaxação (Lower Bound) e a navegação na árvore.
# ==============================================================================

class BranchAndBound:
    def __init__(self, jobs):
        self.jobs = jobs
        self.n = len(jobs)
        self.best_solution = None
        # O 'best_value' é o nosso Upper Bound global. Começa infinito.
        # Se acharmos uma solução completa melhor, atualizamos ele.
        self.best_value = float('inf') 
        self.nodes = []
        self.node_counter = 0
        
    def calculate_weighted_tardiness(self, sequence):
        """Calcula o atraso ponderado total para uma sequência completa"""
        # Essa função é pra quando a gente tem uma solução COMPLETA.
        # Ela calcula o valor real da função objetivo: Soma de w_j * T_j.
        current_time = 0
        total_wt = 0
        
        for job in sequence:
            current_time += job.p # O tempo vai acumulando
            tardiness = max(0, current_time - job.d) # Atraso = max(0, Término - Prazo)
            total_wt += job.w * tardiness # Multiplica pelo peso
            
        return total_wt
    
    def solve_transportation_relaxation(self, remaining_jobs, fixed_jobs, total_time):
        """
        Resolve a relaxação do problema de transporte
        remaining_jobs: jobs ainda não sequenciados
        fixed_jobs: jobs já fixados nas últimas posições
        total_time: tempo total de processamento
        """
        # ==========================================================================
        # IMPORTANTE PRO TRABALHO:
        # O enunciado pede pra usar a relaxação do Problema de Transporte pra achar o Lower Bound.
        # É aqui que a mágica acontece. A gente ignora a ordem exata e tenta encaixar 
        # os jobs nos "slots" de tempo disponíveis da maneira mais barata possível.
        # Isso nos dá um valor otimista (mínimo possível) pra aquele ramo.
        # ==========================================================================
        
        if not remaining_jobs:
            return 0
        
        # Calcular o tempo já usado pelos jobs que JÁ fixamos no final
        fixed_time = sum(job.p for job in fixed_jobs)
        # O tempo disponível pros jobs que sobraram é o total menos o que os finais gastaram
        available_time = total_time - fixed_time
        
        # Ordenar jobs por w_j/p_j decrescente (aproximação gulosa)
        # A gente usa essa lógica pra tentar preencher os slots de forma eficiente na relaxação.
        sorted_jobs = sorted(remaining_jobs, key=lambda j: j.w/j.p, reverse=True)
        
        total_cost = 0
        current_slot = 1
        
        for job in sorted_jobs:
            # Na relaxação, a gente tenta colocar o job o mais cedo possível sem se preocupar
            # tanto com a ordem rígida, mas sim com o custo de ocupar aqueles slots.
            job_start = current_slot
            job_end = job_start + job.p - 1
            
            # Calcular custo baseado nos slots após o prazo
            if job_end > job.d:
                # Quantos slots estão após o prazo
                late_slots = min(job.p, job_end - job.d)
                total_cost += job.w * late_slots
            
            current_slot = job_end + 1
            
            if current_slot > available_time:
                break
        
        return total_cost
    
    def calculate_lower_bound(self, node):
        """Calcula o lower bound para um nó usando a relaxação do problema de transporte"""
        # Aqui juntamos duas coisas pro LB:
        # 1. O custo dos jobs que JÁ decidimos (sequence) - isso é custo real.
        # 2. O custo estimado (relaxado) dos jobs que faltam (remaining) - isso é estimativa otimista.
        
        # Parte 1: Calcular o custo dos jobs já sequenciados (que estão no fim da fila)
        current_cost = 0
        total_time = sum(job.p for job in self.jobs)
        
        # Para cada job na sequência (lembrando que a lista 'node.sequence' tá preenchida de trás pra frente)
        completion_time = total_time
        for job in node.sequence:
            tardiness = max(0, completion_time - job.d)
            current_cost += job.w * tardiness
            completion_time -= job.p # Vamos voltando no tempo
        
        # Se não tem mais jobs pra alocar, o custo é só o atual mesmo
        if not node.remaining_jobs:
            return current_cost
        
        # Parte 2: Chamar a função que faz a relaxação pros jobs que sobraram
        relaxation_cost = self.solve_transportation_relaxation(
            node.remaining_jobs, node.sequence, total_time
        )
        
        # O Lower Bound final desse nó é a soma dos dois
        return current_cost + relaxation_cost
    
    def check_dominance(self, job1, job2):
        """Verifica se job1 deve preceder job2 (Lema 3.6.1)"""
        # O enunciado pediu pra usar o Lema 3.6.1 pra evitar abrir nós desnecessários.
        # Se o job1 tem prazo menor, processamento menor e peso maior que o job2, 
        # ele "domina" e deve vir antes. Isso ajuda a podar a árvore antes mesmo de calcular LB.
        return (job1.d <= job2.d and job1.p <= job2.p and job1.w >= job2.w)
    
    def expand_node(self, node):
        """Expande um nó criando seus filhos"""
        if node.is_complete:
            return []
        
        children = []
        # Tentamos colocar cada job restante na próxima posição livre (de trás pra frente)
        for job in node.remaining_jobs:
            
            # --- Aqui entraria a verificação do Lema 3.6.1 se a gente fosse filtrar antes de criar ---
            
            # Criar novo nó
            new_sequence = node.sequence + [job] # Adiciona esse job na sequência fixa
            new_remaining = [j for j in node.remaining_jobs if j != job] # Remove ele dos pendentes
            child = Node(node.level + 1, new_sequence, new_remaining, parent=node)
            
            # Calculamos o Lower Bound desse filho usando a relaxação
            child.lower_bound = self.calculate_lower_bound(child)
            
            # Atribuir ID pra controle
            child.id = self.node_counter
            self.node_counter += 1
            self.nodes.append(child)
            
            # Se chegamos numa folha (solução completa), verificamos se é a melhor até agora
            if child.is_complete:
                if child.lower_bound < self.best_value:
                    # Opa! Achamos um novo campeão (Upper Bound atualizado)
                    self.best_value = child.lower_bound
                    self.best_solution = child.sequence[::-1]  # Reverter pra ficar na ordem certa (começo pro fim)
                    print(f"Nova melhor solução encontrada: {[j.id for j in self.best_solution]} com valor {self.best_value}")
            
            children.append(child)
            node.children.append(child)
        
        return children
    
    def solve(self):
        """Executa o algoritmo branch-and-bound"""
        # ======================================================================
        # LOOP PRINCIPAL
        # Cria a raiz, coloca na fila e fica processando até acabar ou podar tudo.
        # ======================================================================
        
        # Criar nó raiz (nenhum job sequenciado ainda)
        root = Node(0, [], self.jobs)
        root.lower_bound = self.calculate_lower_bound(root)
        root.id = self.node_counter
        self.node_counter += 1
        self.nodes.append(root)
        
        # Fila de nós ativos para explorar
        active_nodes = deque([root])
        
        print("=== EXECUÇÃO DO BRANCH-AND-BOUND ===\n")
        
        while active_nodes:
            # ESTRATÉGIA DE BUSCA: Best-First Search
            # A gente ordena a fila pra pegar sempre o nó com MENOR Lower Bound primeiro.
            # Isso faz a gente chegar na solução boa mais rápido.
            active_nodes = deque(sorted(active_nodes, key=lambda x: x.lower_bound))
            current_node = active_nodes.popleft()
            
            print(f"Explorando nó {current_node} com LB = {current_node.lower_bound}")
            
            # REGRA DE PODA (PRUNING):
            # Se o LB desse nó já é pior ou igual ao melhor valor que já encontramos numa solução completa,
            # nem adianta continuar explorando ele. Corta!
            if current_node.lower_bound >= self.best_value:
                current_node.pruned = True
                print(f"  Nó podado (LB >= melhor solução: {current_node.lower_bound} >= {self.best_value})")
                continue
            
            # Se não podou, expande (cria os filhos)
            children = self.expand_node(current_node)
            
            for child in children:
                print(f"  Filho {child} com LB = {child.lower_bound}")
                
                # Se o filho for promissor (LB menor que o best_value) e não for folha, põe na fila.
                if child.lower_bound < self.best_value and not child.is_complete:
                    active_nodes.append(child)
                # Se o filho já nasceu ruim (LB alto), já marca como podado.
                elif child.lower_bound >= self.best_value:
                    child.pruned = True
                    print(f"    Podado (LB >= melhor solução)")
            
            print()
        
        return self.best_solution, self.best_value
    
    # ==========================================================================
    # PARTE 3: VISUALIZAÇÃO
    # Funções auxiliares só pra gerar o gráfico com Matplotlib pedido no trabalho.
    # ==========================================================================

    def assign_positions(self):
        """Atribui posições aos nós para visualização"""
        # Organiza os nós por nível pra árvore ficar bonitinha, piramidal.
        levels = {}
        for node in self.nodes:
            if node.level not in levels:
                levels[node.level] = []
            levels[node.level].append(node)
        
        # Calcula X e Y pra cada bolinha
        for level, nodes_in_level in levels.items():
            n_nodes = len(nodes_in_level)
            for i, node in enumerate(nodes_in_level):
                x = (i - (n_nodes - 1) / 2) * 150 # Espaçamento horizontal
                y = -level * 100                  # Espaçamento vertical
                node.position = (x, y)
    
    def visualize_tree(self):
        """Visualiza a árvore de branch-and-bound"""
        self.assign_positions()
        
        fig, ax = plt.subplots(figsize=(16, 12))
        
        # Desenhar as linhas conectando pai e filho
        for node in self.nodes:
            if node.parent:
                x1, y1 = node.parent.position
                x2, y2 = node.position
                ax.plot([x1, x2], [y1, y2], 'k-', alpha=0.5, zorder=1)
        
        # Desenhar as bolinhas (nós)
        for node in self.nodes:
            x, y = node.position
            
            # Cores pra facilitar a leitura do professor/aluno:
            # Verde: É a solução ótima final.
            # Vermelho: Foi podado (paramos de explorar ali).
            # Azul: Nó normal explorado.
            if node.is_complete and node.lower_bound == self.best_value:
                color = 'lightgreen'
                edge_color = 'green'
                linewidth = 3
            elif node.pruned:
                color = 'lightcoral'
                edge_color = 'red'
                linewidth = 2
            else:
                color = 'lightblue'
                edge_color = 'black'
                linewidth = 1
            
            # Desenha o círculo
            circle = plt.Circle((x, y), 30, facecolor=color, 
                              edgecolor=edge_color, linewidth=linewidth, zorder=2)
            ax.add_patch(circle)
            
            # Texto dentro e fora do nó (ID e Lower Bound)
            ax.text(x, y+5, str(node), ha='center', va='center', fontsize=8, weight='bold')
            ax.text(x, y-10, f"LB={node.lower_bound:.0f}", ha='center', va='center', fontsize=7)
        
        # Título e legenda
        ax.set_title("Árvore Branch-and-Bound para 1||∑w_jT_j", fontsize=14, weight='bold')
        
        # Legenda explicando as cores
        legend_elements = [
            mpatches.Patch(facecolor='lightgreen', edgecolor='green', linewidth=3, label='Solução Ótima'),
            mpatches.Patch(facecolor='lightcoral', edgecolor='red', linewidth=2, label='Nó Podado'),
            mpatches.Patch(facecolor='lightblue', edgecolor='black', linewidth=1, label='Nó Explorado')
        ]
        ax.legend(handles=legend_elements, loc='upper right')
        
        ax.set_aspect('equal')
        ax.axis('off')
        plt.tight_layout()
        plt.show()

# ==============================================================================
# PARTE 4: EXECUÇÃO
# Aqui a gente cria a instância de teste e roda tudo.
# ==============================================================================

# Criar instância do problema (Exemplo do enunciado)
jobs = [
    Job(1, 14, 20, 5),
    Job(2, 6, 45, 10),
    Job(3, 8, 30, 20),
    Job(4, 7, 18, 10),
    Job(5, 12, 35, 20),
    Job(6, 11, 55, 10)
]

# Instanciar a classe e mandar resolver
bb = BranchAndBound(jobs)
solution, value = bb.solve()

# Imprimir resultados finais formatados
print("\n=== SOLUÇÃO ÓTIMA ===")
print(f"Sequência: {[job.id for job in solution]}")
print(f"Valor ótimo: {value}")
print("\n=== DETALHES DA SOLUÇÃO ===")

current_time = 0
total_wt = 0
for job in solution:
    current_time += job.p
    tardiness = max(0, current_time - job.d)
    wt = job.w * tardiness
    total_wt += wt
    print(f"Job {job.id}: C_{job.id}={current_time}, T_{job.id}={tardiness}, w_{job.id}*T_{job.id}={wt}")

print(f"\nSoma total dos atrasos ponderados: {total_wt}")

# Chama a função que abre a janela com o gráfico da árvore
bb.visualize_tree()

# Estatísticas pra colocar no relatório
print(f"\n=== ESTATÍSTICAS ===")
print(f"Total de nós criados: {bb.node_counter}")
print(f"Nós podados: {sum(1 for n in bb.nodes if n.pruned)}")
print(f"Soluções completas avaliadas: {sum(1 for n in bb.nodes if n.is_complete)}")

# ==============================================================================
# VALIDAÇÃO (FORÇA BRUTA)
# Isso aqui é só pra gente ter certeza absoluta que o B&B funcionou. 
# Ele testa TODAS as permutações possíveis (fatorial!) pra ver se bate.
# ==============================================================================
print("\n=== VALIDAÇÃO (Força Bruta) ===")
from itertools import permutations

best_seq = None
best_val = float('inf')
for perm in permutations(jobs):
    val = bb.calculate_weighted_tardiness(list(perm))
    if val < best_val:
        best_val = val
        best_seq = list(perm)

print(f"Melhor sequência por força bruta: {[j.id for j in best_seq]}")
print(f"Valor ótimo por força bruta: {best_val}")
