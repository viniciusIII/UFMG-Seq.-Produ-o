import pulp
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# ==============================================================================
# 1. ESTRUTURAS DE DADOS
# ==============================================================================

class Job:
    """
    Representa um job com seus dados básicos.
    - id: identificador do job
    - p: tempo de processamento
    - d: due date
    - w: peso (importância do atraso)
    
    Essa estrutura é exatamente a mesma usada no livro do Pinedo.
    """
    def __init__(self, id, p, d, w):  # CORRIGIDO: __init__ com dois underscores
        self.id = id
        self.p = p
        self.d = d
        self.w = w

    def __repr__(self):  # CORRIGIDO: __repr__ com dois underscores
        # Facilita a impressão de sequências
        return f"J{self.id}"


class Node:
    """
    Cada nó da árvore de Branch and Bound representa uma SEQUÊNCIA PARCIAL
    construída DE TRÁS PARA FRENTE, exatamente como sugerido pelo Pinedo.

    scheduled_jobs: jobs já fixados nas ÚLTIMAS posições da sequência.
    remaining_jobs: jobs que ainda podem preencher as posições restantes.
    level: profundidade do nó (quantos jobs já foram fixados).

    O nó armazena:
    - lower_bound: valor da relaxação (problema do transporte)
    - exact_value: custo real se a sequência estiver completa
    - status: usado para podas e visualização
    """
    def __init__(self, level, scheduled_jobs, remaining_jobs, parent=None):  # CORRIGIDO
        self.level = level
        self.scheduled_jobs = scheduled_jobs      # sequência parcial (de trás para frente)
        self.remaining_jobs = remaining_jobs      # jobs que ainda podem entrar
        self.parent = parent
        self.children = []

        self.lower_bound = float('inf')           # LB obtido pelo problema de transporte
        self.exact_value = None                   # custo real (só quando a sequência está completa)
        self.local_upper_bound = float('inf')     # melhor valor inteiro conhecido na subárvore

        # status para debug/visualização do B&B:
        # 'active', 'pruned_dominance', 'pruned_bound', 'optimal', 'explored', 'suboptimal_leaf'
        self.status = 'active'

        self.id = None               # identificador único do nó
        self.position = (0, 0)       # usado só na visualização

    def __repr__(self):  # CORRIGIDO
        """
        Representação visual do nó no formato:
        (*, *, J3, J6)
        onde * são posições ainda não definidas.
        """
        fixed_part = [str(j.id) for j in self.scheduled_jobs[::-1]]
        stars = ["*"] * len(self.remaining_jobs)
        content = ",".join(stars + fixed_part)
        return f"({content})"


# ==============================================================================
# 2. SOLVER BRANCH AND BOUND — PINEDO 3.6
# ==============================================================================

class PinedoSolver:
    """
    Implementa o algoritmo de Branch-and-Bound exatamente como descrito
    na Seção 3.6 do livro do Pinedo para o problema:

            1 | | Σ w_j * T_j

    A árvore é construída DE TRÁS PARA FRENTE:
    - No nível 0 nenhum job foi colocado na sequência.
    - No nível 1 define-se o job que fica na última posição.
    - No nível 2 define-se o penúltimo job.
    - E assim por diante.

    Para cada nó calculamos um LOWER BOUND resolvendo o
    PROBLEMA DE TRANSPORTE (relaxação linear), como Pinedo ensina.

    Também aplicamos o *Lema 3.6.1* para eliminar jobs dominados.
    """
    def __init__(self, jobs):  # CORRIGIDO
        self.jobs = jobs
        self.n = len(jobs)

        # Cmax = soma dos tempos, limite superior de tempo no PL do transporte
        self.total_makespan = sum(j.p for j in jobs)

        # melhor custo já encontrado (upper bound global)
        self.best_solution = None
        self.upper_bound = float('inf')

        # lista de todos os nós gerados
        self.nodes = []
        self.node_counter = 0


    # ----------------------------------------------------------------------------
    # Função auxiliar — calcula o custo REAL de uma sequência completa
    # ----------------------------------------------------------------------------
    def calculate_exact_weighted_tardiness(self, sequence):
        """
        Computa a soma de w_j * T_j de uma sequência completa.
        Isso é usado quando chegamos numa folha da árvore.
        """
        time = 0
        total_wt = 0
        for job in sequence:
            time += job.p
            tardiness = max(0, time - job.d)
            total_wt += job.w * tardiness
        return total_wt


    # ----------------------------------------------------------------------------
    # LOWER BOUND — relaxação via problema de transporte (modelo do Pinedo)
    # ----------------------------------------------------------------------------
    def solve_transportation_relaxation(self, node):
        """
        Resolve o PL do problema do transporte como lower bound.

        Modelo do Pinedo (Ex. 3.6.3):
        - Cada job j é "quebrado" em p_j unidades de processamento.
        - x_{j,k} = 1 se uma unidade do job j é processada no tempo k.
        - Cada tempo pode receber no máximo 1 unidade.
        - Cada job deve receber exatamente p_j unidades.
        - Custos c_{jk} = 0 se k ≤ d_j; c_{jk} = w_j se k > d_j.

        Além disso, como estamos montando a sequência DE TRÁS PRA FRENTE,
        já sabemos a posição final de alguns jobs.
        Então, as variáveis x_{j,k} desses jobs são FIXADAS = 1
        nos tempos correspondentes, exatamente como o Pinedo pede.
        """

        # Caso especial: nó totalmente vazio
        if not node.remaining_jobs and not node.scheduled_jobs:
            return 0

        prob = pulp.LpProblem(f"Node_{node.id}", pulp.LpMinimize)
        Cmax = self.total_makespan

        # Todos os jobs relevantes (os que ainda faltam + os já fixados)
        all_jobs = node.remaining_jobs + node.scheduled_jobs

        # Variáveis x[j,k]
        x = {}
        for job in all_jobs:
            for k in range(1, Cmax + 1):
                x[(job.id, k)] = pulp.LpVariable(f"x_{job.id}_{k}", 0, 1)

        # Função objetivo: soma dos custos c_{jk} * x_{jk}
        obj_terms = []
        for job in all_jobs:
            for k in range(1, Cmax + 1):
                if k > job.d:         # está atrasado
                    obj_terms.append(job.w * x[(job.id, k)])
        prob += pulp.lpSum(obj_terms)

        # Cada job precisa preencher exatamente p_j unidades
        for job in all_jobs:
            prob += pulp.lpSum(x[(job.id, k)] for k in range(1, Cmax + 1)) == job.p

        # Cada tempo pode processar no máximo 1 unidade
        for k in range(1, Cmax + 1):
            prob += pulp.lpSum(x[(job.id, k)] for job in all_jobs) <= 1

        # Fixação das variáveis dos jobs já posicionados no final da sequência
        current_end = Cmax
        for job in node.scheduled_jobs:
            start = current_end - job.p + 1
            end = current_end

            # Fixando x_{j,k} = 1 para os tempos ocupados
            for k in range(start, end + 1):
                prob += x[(job.id, k)] == 1

            # Avança
            current_end -= job.p

        # Resolve o PL
        prob.solve(pulp.PULP_CBC_CMD(msg=0))

        # Se o PL não achar solução, retorna infinito
        if prob.status != pulp.LpStatusOptimal:
            return float('inf')

        return pulp.value(prob.objective)


    # ----------------------------------------------------------------------------
    # LEMMA 3.6.1 — dominância de jobs
    # ----------------------------------------------------------------------------
    def check_dominance(self, job_j, job_k):
        """
        Implementa o Lema 3.6.1 exatamente como escrito no livro.

        Se:
            d_j <= d_k  (job j vence no prazo)
            p_j <= p_k  (j é mais curto)
            w_j >= w_k  (j é mais importante)
        então sempre existe uma sequência ótima onde j vem ANTES de k.

        Logo, podemos PODAR qualquer nó onde k venha antes de j.
        """
        if job_j.id == job_k.id:
            return False

        if (job_j.d <= job_k.d) and (job_j.p <= job_k.p) and (job_j.w >= job_k.w):
            return True
        return False


    # ----------------------------------------------------------------------------
    # MÉTODO PRINCIPAL — executa o Branch and Bound completo
    # ----------------------------------------------------------------------------
    def solve(self):
        print("=" * 60)
        print(" INICIANDO BRANCH AND BOUND ")
        print("=" * 60)

        # Nó raiz: ninguém foi escalonado ainda
        root = Node(0, [], self.jobs)
        root.id = self.node_counter
        self.node_counter += 1

        # Lower bound do nó raiz
        root.lower_bound = self.solve_transportation_relaxation(root)
        self.nodes.append(root)

        # Fila de nós ativos
        queue = [root]

        # ---------------------------
        # LOOP PRINCIPAL DO B&B
        # ---------------------------
        while queue:

            # Escolher o nó com menor lower bound
            queue.sort(key=lambda n: n.lower_bound)
            curr = queue.pop(0)

            if curr.status == "active":
                curr.status = "explored"

            #print(f"Explorando Nó {curr} | LB: {curr.lower_bound}")

            # PODA 1: LB >= UB
            if curr.lower_bound >= self.upper_bound - 0.001:
                curr.status = 'pruned_bound'
                continue

            # CASO 2: nó folha (sequência completa)
            if not curr.remaining_jobs:
                seq_ordered = curr.scheduled_jobs[::-1]
                val_real = self.calculate_exact_weighted_tardiness(seq_ordered)
                curr.exact_value = val_real
                curr.local_upper_bound = val_real
                self._propagate_local_ub(curr.parent, val_real)

                if val_real < self.upper_bound:
                    self.upper_bound = val_real
                    self.best_solution = seq_ordered
                    print(f" >>> NOVO UB ENCONTRADO: {self.upper_bound} <<<")
                else:
                    curr.status = 'suboptimal_leaf'
                continue

            # EXPANSÃO DOS FILHOS
            for job in curr.remaining_jobs:

                # Teste de dominância usando Lemma 3.6.1
                is_dominated = False
                for other in curr.remaining_jobs:
                    if self.check_dominance(job, other):
                        is_dominated = True
                        break

                # Monta o novo nó (adicionando o job no final da sequência)
                new_rem = [j for j in curr.remaining_jobs if j.id != job.id]
                new_sch = curr.scheduled_jobs + [job]
                child = Node(curr.level + 1, new_sch, new_rem, parent=curr)
                child.id = self.node_counter
                self.node_counter += 1
                self.nodes.append(child)
                curr.children.append(child)

                # PODA POR DOMINÂNCIA
                if is_dominated:
                    child.status = 'pruned_dominance'
                    child.lower_bound = float('inf')
                    continue

                # Calcula LB da relaxação
                child.lower_bound = self.solve_transportation_relaxation(child)

                # Verifica se merece entrar na fila
                if child.lower_bound < self.upper_bound:
                    child.status = 'active'
                    queue.append(child)
                else:
                    child.status = 'pruned_bound'

            # Atualiza UB local a partir dos filhos já avaliados
            child_values = [c.local_upper_bound for c in curr.children if c.local_upper_bound < float('inf')]
            if child_values:
                curr.local_upper_bound = min(child_values)
                self._propagate_local_ub(curr.parent, curr.local_upper_bound)

        # Após percorrer tudo, marcamos o caminho ótimo para a visualização
        self.mark_optimal_path()

        return self.best_solution, self.upper_bound

    def _propagate_local_ub(self, node, value):
        """Propaga o melhor UB conhecido para cima na árvore."""
        while node:
            if value < node.local_upper_bound:
                node.local_upper_bound = value
                node = node.parent
            else:
                break

    def mark_optimal_path(self):
        """Rastreia o caminho vencedor para pintar de verde na visualização."""
        if not self.best_solution: 
            return
        
        target = self.best_solution[::-1] # A árvore guarda invertido
        best_leaf = None
        
        # Acha a folha que gerou o valor ótimo
        for node in self.nodes:
            if not node.remaining_jobs and node.scheduled_jobs == target:
                if node.exact_value == self.upper_bound:
                    best_leaf = node
                    break
        
        curr = best_leaf
        while curr:
            curr.status = 'optimal'
            curr = curr.parent
            
    # ==============================================================================
    # 3. VISUALIZAÇÃO FILTRADA
    # ==============================================================================

    def assign_positions(self, nodes_to_draw):
        """Atribui posições apenas aos nós que serão desenhados"""
        levels = {}
        for node in nodes_to_draw:
            if node.level not in levels:
                levels[node.level] = []
            levels[node.level].append(node)
        
        # Ordena para manter o "caminho ótimo" tendendo ao centro visualmente
        for lvl in levels:
            levels[lvl].sort(key=lambda n: (n.parent.position[0] if n.parent else 0, n.status != 'optimal'))

        for level, nodes_in_level in levels.items():
            n_nodes = len(nodes_in_level)
            for i, node in enumerate(nodes_in_level):
                x = (i - (n_nodes - 1) / 2) * 180 # Mais espaçamento horizontal
                y = -level * 120
                node.position = (x, y)

    def visualize_tree(self):
        """Visualiza APENAS o caminho ótimo e os nós podados adjacentes"""
        
        # --- FILTRAGEM ---
        # Regra: Mantemos o nó se ele é raiz ou o pai dele é ÓTIMO
        nodes_to_draw = [
            node for node in self.nodes 
            if node.level == 0 or (node.parent and node.parent.status == 'optimal')
        ]
        
        # Atribuir posições apenas para o subconjunto
        self.assign_positions(nodes_to_draw)
        
        fig, ax = plt.subplots(figsize=(16, 10))
        
        # 1. Desenhar Linhas
        for node in nodes_to_draw:
            if node.parent and node.parent in nodes_to_draw:
                x1, y1 = node.parent.position
                x2, y2 = node.position
                
                if node.status == 'optimal' and node.parent.status == 'optimal':
                    color_line = 'green'
                    lw_line = 3.0
                    alpha_line = 1.0
                    style = '-'
                else:
                    color_line = 'red'
                    lw_line = 1.5
                    alpha_line = 0.8
                    style = '--'

                ax.plot([x1, x2], [y1, y2], color=color_line, linewidth=lw_line, 
                        linestyle=style, alpha=alpha_line, zorder=1)
        
        # 2. Desenhar Nós
        for node in nodes_to_draw:
            x, y = node.position

            if node.status == 'optimal':
                face_color = '#90EE90'
                edge_color = 'green'
                linewidth = 3
            elif node.status == 'pruned_dominance':
                face_color = '#FFA7A7'
                edge_color = '#8B0000'
                linewidth = 5          # borda mais grossa para dominância
            else:
                face_color = '#FFA7A7'
                edge_color = 'red'
                linewidth = 2

            circle = mpatches.Circle((x, y), 55,  # raio maior para caber texto
                                     facecolor=face_color,
                                     edgecolor=edge_color,
                                     linewidth=linewidth,
                                     zorder=2)
            ax.add_patch(circle)
            
            # Texto Central (,,J)
            node_text = str(node)
            if len(node_text) > 15:
                node_text = node_text.replace(',', ',\n')

            ax.text(x, y+20, node_text, ha='center', va='center',
                    fontsize=8, weight='bold', zorder=3)
            
            # Texto Inferior (Valores)
            if node.remaining_jobs:
                if node.lower_bound == float('inf'):
                    lb_text = "ẓ = ∞"
                else:
                    lb_text = f"ẓ = {node.lower_bound:.0f}"
                if node.local_upper_bound < float('inf'):
                    lb_text += f"\nż = {node.local_upper_bound:.0f}"
                else:
                    lb_text += ""
            else:
                lb_text = f"Real: {node.exact_value}"
                
            if node.status == 'pruned_dominance':
                lb_text += "\nLemma \n3.6.1"
            elif node.status == 'pruned_bound':
                lb_text += "\n(ẓ ≥ ż)"
            elif node.status == 'suboptimal_leaf':
                lb_text += "\n(Folha pior)"
                
            ax.text(x, y-20, lb_text, ha='center', va='center', fontsize=8, zorder=3)
        
        ax.set_title(f"Árvore Otimizada - Custo Ótimo: {self.upper_bound}", fontsize=14, weight='bold')
        
        legend_elements = [
            mpatches.Patch(facecolor='#90EE90', edgecolor='green', linewidth=3, label='Caminho Ótimo'),
            mpatches.Patch(facecolor='#FFA7A7', edgecolor='red', linewidth=2, label='Nós Podados')
        ]
        ax.legend(handles=legend_elements, loc='upper right')
        
        ax.set_aspect('equal')
        ax.axis('off')
        ax.autoscale_view()
        plt.tight_layout()
        plt.show()

# ==============================================================================
# 4. EXECUÇÃO
# ==============================================================================

jobs_data = [
    Job(1, 14, 20, 5),
    Job(2, 6, 45, 10),
    Job(3, 8, 30, 20),
    Job(4, 7, 18, 10),
    Job(5, 12, 35, 20),
    Job(6, 11, 55, 10)
]

print(f"Jobs: {jobs_data}")

solver = PinedoSolver(jobs_data)
best_seq, best_val = solver.solve()

print("\n" + "="*60)
print(f"Solução Ótima Final: {best_val}")
print("="*60)

solver.visualize_tree()
